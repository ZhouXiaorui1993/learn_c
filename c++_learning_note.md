# C++学习笔记

---

## 基础知识

### 基本组成
 
- 预处理命令： 以#开始，包括宏定义命令、文件包含命令和条件编译命令。

- 函数：可以是系统提供的库函数或是用户自定义的函数，但函数中有且只有一个main函数，且程序永远从main函数开始执行。

- 语句：组成程序的基本单元。

- 变量：数据存放在内存单元中，变量是用于存储和访问数据的标识符。

- 输入/输出： 接收用户输入，返回程序运行的结果。

- 注释：帮助阅读，以`//`开头。

---

## 变量和数据类型

### 常量

C++中数据可分为常量和变量两大类，都必须遵循“先声明，后使用”的原则。
        
#### 声明常量

根据定义方法，常量可分为两种：
    
- const常量（符号常量）：

    定义形式为：
  
    ```
        <const>  <类型名>  <常量名>  = <表达式>；
    ```
    声明规则：
    
    - 必须以const开头
    - 类型名必须为基本类型及其派生类型，可省略
    - 常量名必须为标识符
    - 表达式应和常量类型一致

- 宏常量

    定义形式为：
    
    ```
        # define  <宏名>  <常量>
    ```
    
    声明规则：  
    
    - 宏名可以是简单的字符名，也可以是带有参数的函数名
    - 常量可以是数值、字符串或函数等
    
### 变量

### 声明变量

声明的一般形式如下：

```
    [<存储类> ]  <类型名或类型定义>  <变量名表>；
``` 

其中，存储类指的是变量的存储位置，一般来说有以下四种类型：

- auto：属于一次性存储位置，其存储空间可被若干变量多次覆盖使用
- register：存放在通用寄存器中
- extern：在所有函数和程序段中都可引用
- static：在内存中是以固定地址存放的，在整个程序运行期间都有效

注意： `[<存储类> ] `的方括号表示其可以缺省，在默认情况下，变量的存储类值为auto类型。

类型名指变量所属的数据类型，一般为基本数据类型或枚举类型等。

变量名表是指声明的变量的名称，此外，可以在声明的同时对其赋初值，因此，变量名表的格式主要有以下三种：

- <变量名>
- <变量名> = <表达式>
- <变量名 1> = [<表达式 2>] , <变量名 2> = [<表达式 2>] , ...

### 变量的作用范围

在C++中，声明的变量主要分为全局变量和局部变量，其可以出现在程序的任何位置，在不同的位置声明，作用域不同。

- 全局变量： 其说明语句不在任何一个类定义、函数定义或复合语句（程序块）中的变量。全局变量所占用的空间在内存的数据区，在程序运行的整个过程中位置保持不变。

- 局部变量：其说明语句在某一个类定义、函数定义或复合语句（程序块）中的变量。它所占用的空间在为程序运行时所设置的临时工作区中，以堆栈的形式允许反复占用和释放。

### 基本数据类型

C++的数据类型包括基本数据类型和构造数据类型两类，后者又称为符合数据类型，是一种更高级的抽象。这里先介绍基本数据类型：

- 整型： 说明符为int
- 字符型：说明符为char
- 浮点型：说明符为float（单精度）、double（双精度）
- 布尔型：说明符为bool

上述几种类型前面还可以加上不同的修饰符改变原来的含义，主要有以下几种：

- signed：表示有符号
- unsigned：表示无符号
- long：表示长型
- short：表示短型

上述四种修饰符都适用于整型和字符型，只有long还适用于双精度浮点型。

#### 整型

对于整型常量，用户可根据需要用十进制、八进制和十六进制来书写：

- 十进制：由数字0~9和正负号组成
- 八进制：以数字0开头的数字序列（0~7），如0126,010245等
- 十六进制：以0x或0X开头的数字(加A-F)序列，如0x78AC等

### 字符型

字符型数据只占用一个字节，可给其加上signed和unsigned修饰符，分别表示无符号字符型和有符号字符型。

```
    char ch;  // ch可取任意ASCII码为-128~127的字符
```
注意：用一对单引号括起来的为一个字符，而用一对双引号括起来的一个或多个字符序列表示字符串，不能用双引号代替单引号。

 字符串中的字符数称为该字符串的长度，在存储时，系统会自动在字符串的末尾加一个转义字符`'\0'`表示字符串的结束标志。

### 浮点型

- 单精度浮点型（float）：占用4个字节，32位存储空间
- 双精度浮点型（double）：占用8个字节，64位存储空间

### 布尔型

布尔型只有两个值：true和false。

- 如果整型值为0，则其布尔值为假；
- 如果整型值为1，则其布尔值为真。

**注意**：如果在算术表达式中使用bool型变量，则将根据其值的真假而赋予变量1或0。

## 类型转换

用来把一个类型的值转换为另一个类型，C++中，有隐式转换和显示转换两种方式。

### 隐式转换

系统默认的，无需加以声明就可以进行的转换，比如从int类型到long类型、从char类型到int类型都属于隐式转换。
隐式转换一般不会失败，转换过程中也不会造成信息丢失。

### 显示转换

指用户手动指出需要转换的类型，分为两种，一种是简单的用括号将所需要转换的数据类型括起来即可，例如：

```
    int a = 100;
    long b;
    b = (long)a;
```
或者把变量括起来放在类型前：

```
    int a = 30;
    char b = char(a);
```
另一种则是C++特有的（C语言没有）四种显示类型转换的操作符，用法如下：

- static_cast<type id>(expression)：它支持典型的窄化转换（有信息丢失）、void*强制转换、隐式类型转换和类层次转换。例如窄化转换：

```
    double d = 0.0;
    int i;
    i = d;  //由于double比int占用的字节数要大，故从double转换到int会有信息丢失，所以编译器会有警告
    i = static_cast<int>(d);  // 使用该操作符变换则不会出现警告
```

- const_cast<type_id>(expression)：可以将一个const对象转换为非const对象，这样就可以修改其值了，反过来转换也是可以的。另外，还可以用来进行volatile的转换。
    注意：type_id必须为指针或引用。
    
- dynamic_cast<type_id>(expression)：先不介绍。
- reinterpret_cast<type_id>(expression)：pass

---

## 运算符和表达式

### 运算符

C++中包含了C语言中的运算符和表达式，基本运算符有：

- 算术运算符：加减乘除、自增自减、取余等运算。

- 关系运算符：大于小于、大于等于、小于等于、等于（==）、不等于（！=）。

- 逻辑运算符：逻辑非（！）、逻辑与（&&）、逻辑或（||）。

- 位运算符：按位与（&）、按位或（|）、按位异或（^）、左移位、右移位、按位取反。

- 条件运算符：比较特殊的运算符，一般形式为：

```
    <表达式1>?<表达式2>:<表达式3>  // 先求解1，如果值为true，则求解2作为最终结果；若1的值为false，则求解3作为最终结果
```
注意：表达式1必须返回bool类型。

- 赋值运算符

- 逗号运算符

- sizeof 运算符：由于不同的计算机支持的数据类型长度是不一样的，所以需要一个运算符用来测量该机器中的数据类型长度。sizeof运算符即是为此而设计的，其使用格式如下：

```
    sizeof(<类型名或表达式名>)  // 运算结果为类型名所表示的类型的长度或表达式的值所占用的字节数，即这个值所属类型的长度
``` 

- 其他运算符

此外，又增加了一些新的运算符：

- ` :: `作用域运算符

- `new `动态分配内存单元运算符

- `delete` 删除动态分配的内存单元运算符

- `* `成员运算符和`->*`成员指针运算符

### 语句

- 空语句：直接是一个分号，不进行任何操作，相当于Python中的pass语句。

- 声明语句

- 赋值语句

---

## 程序控制结构

### 顺序结构

指按照所有语句的出现顺序先后执行，包含表达式语句、输入语句和输出语句。

- 表达式语句

- 输入/输出语句

实际上，C++没有提供输入/输出语句，其输入输出由函数（scanf、printf）或流控制来实现。输入/输出流（I/O流）是输入或输出的一系列字节。C++定义了包含重载运算符`“<<”`和`“>>”`的iostream类。在I/O流类定义中，将C++语言中的左移位、右移位运算符通过运算符重载的方法定义为插入（输出）和提取（输入）运算符。

注意：在输出中，关键字endl可以表示换行。

- 流控制成员函数和格式控制符

为了更好的调整输入输出的格式，C++还提供了格式控制符和格式控制函数。

- 格式控制符的用法：

```
    int a=100;
    cout<<"十进制:"<<dec<<a<<endl; //以十进制形式输出整数，默认即为十进制，故可省略
    cout<<"十六进制："<<hex<<a<<endl; //以十六进制的形式输出
    cout<<"八进制："<<oct<<a<<endl;
 	// cout<<"二进制："<<setbase(2)<<a<<endl; //不生效，没有二进制的输出格式
 	// 控制输出宽度
 	string b="zhouxr";
 	cout<<"指定宽度为10："<<setw(10)<<b<<endl;
 	cout<<"指定宽度为10，空白处用*号填充："<<setfill('*')<<setw(10)<<b<<endl;
 	//浮点数输出，也可以用以上方法指定宽度，这里略过
 	double pi=22.0/7.0;
 	cout<<"默认输出：pi = "<<pi<<endl;
 	cout<<"指数形式输出："<<setiosflags(ios::scientific)<<setprecision(8);  //指数形式输出，保留八位小数
 	cout<<pi<<endl;
 	cout<<"改为4位小数："<<setprecision(4)<<pi<<endl;
 	cout<<"取消指数输出设置，改为小数形式输出："<<setiosflags(ios::fixed)<<pi<<endl;
```

- 流成员函数的用法：

```
    int a = 21;
	cout.setf(ios::showbase); //显示基数符号
	cout<<"dec:"<<a<<endl;
	cout.unsetf(ios::dec); //终止十进制格式
	cout.setf(ios::hex);  //设置为16进制
	cout<<"hex:"<<a<<endl;
	cout.unsetf(ios::hex);  //终止16进制
	
	const char* pt="zhouxr";
	cout.width(10);  //指定输出宽度
	cout.fill('*');  //空白处填充‘*’
	cout<<pt<<endl;  
```
格式标志在ios类中定义，可以百度到。

### 选择结构

#### if语句

```
    if (<表达式1>)
        <语句1>；
    else if (<表达式2>)
        <语句2>；
    ...
    else
        <语句n>；
```

#### switch语句

```
    switch (<表达式>)
    {
        case <常量表达式1>:
            <语句1>;
            break;
        ...
        case <常量表达式n>:
            <语句n>;
            break;
        default:
            <语句n+1>;
            break;
    }
```
### 循环结构

#### for语句

```
    for(<表达式1>;<表达式2>;<表达式3>)
    {
        <语句>；
    }
```

注：表达式1是对循环控制变量的初始化，表达式2是循环条件，表达式3是对循环变量进行递增或递减。这三个表达式都可以缺省，但分号不可省略。

#### while语句

```
    while (<表达式>)  // 表达式不成立时，退出循环
    {
        <语句>;
    }
```
注意：for语句与while语句的区别在于，前者更加精简，后者可读性更强。

#### do...while语句

```
    do
    {
        <语句>;
    }
    while (<表达式>)；  // 当表达式不成立时，退出循环  
```
    
注意：while语句和do...while语句的区别在于，后者至少执行一次，前者可能不会被执行。

**在C++中，最常用的循环语句是for语句**

#### 转向语句

转向语句是用来实现无条件转移的语句，常用的有以下四种：

- break语句：用来结束循环，然后执行循环体后面的语句。也可以作为switch语句的出口，用来结束case语句。

- continue语句：用来跳出本次循环进入下一次循环。

- goto语句：用来将程序无条件跳转到指定的标号语句，其说明语句一般形式如下：

```
    goto<标号>；
```
其中，标号是一个标识符，放在语句的最前面，其说明语句的一般形式如下：

```
    <标号>:<语句>
```
注意：使用goto语句会使程序的结构不清晰，因此应尽量少用或不用该语句。

- return语句：可用来停止执行当前函数，转而执行调用该函数后面的语句，其说明语句的一般形式如下：

```
    return <表达式>;
```
其中，表达式可以是任何类型的变量，也可以是void型。需要注意的是，所返回的表达式的类型必须与函数类型一致。

---

##函数

###定义函数
    
    在C++程序中，调用函数前，首先需要对函数进行定义（定义必须写在调用之前，不然会产生编译错误）。为了使函数的调用不受函数定义位置的影响，可以在调用前进行函数的声明。

函数定义的一般形式如下：
```
    返回类型 函数名 (参数列表)
    {
        函数体
    }
```   
包括以下几部分：
   
- 函数名：一个符合C++语法要求的标识符

- 参数列表：参数可以有0个或多个（有多个时，需要用逗号隔开），写在圆括号内，用于向函数传递数值或从函数带回返回值，每一个参数都有自己的类型。
    
- 返回类型：即指定函数用return返回的函数值的类型，如果函数没有返回值，则应为void。每个函数都有类型，如果在函数定义时没有明确指定返回类型，则默认类型为int。    
    
- 函数体：函数的主体部分。

函数的声明可以写作：

```
    返回类型 函数名(参数1类型， 参数2类型，...)；  // 例如 int func(float, int);
```
###main()函数

在C++中，main()函数中允许带两个参数，一个是argc，整型数据类型；一个是指向字符型的指针数组（存储的为string）argv[]，它们在main()函数中声明的格式为：
```
    int main(int argc, char *argv[ ])
```
其中，argc表示命令行中字符串的个数，argv[ ]指向命令行中的各个字符串（argv[0]存储的是可执行文件所在路径）。

###函数调用

#### 调用格式

一般来说，常见的函数调用有以下两种：

- 将函数调用作为一条语句使用，只要求函数完成一定的操作，而不使用其返回值。若存在返回值，则返回值将自动丢失。

- 将函数调用作为语句的一部分，使用函数的返回值参与相应的运算或执行相应的操作。

#### 参数传递

根据参数传递的方式，函数调用分为两种不同的方式，一种是按值传递，另一种是按地址传递或引用传递。前者的传递过程为：

1. 计算出实参表达式的值，接着为对应的形参变量分配一个存储空间，该空间的大小等于该形参类型的长度；

2. 把已求出的实参表达式的值一一存入为形参变量分配的存储空间中，成为形参变量的初值，供被调用的函数执行时使用。

简单来讲，传值调用就是指当一个函数被调用时，C++根据实参和形参的对应关系将实参的值一一复制给形参，即实参的值单向传递给形参。函数本身不对实参进行任何操作，
即使形参的值在函数中改变，实参的值也不会受到影响。

#### 引用调用

引用传递过程中，被调函数的形式参数虽然也作为局部变量在堆栈中开辟了内存空间，但这时存放的是主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过堆栈中存放的地址访问主调函数中的实参变量。因此，被调函数对形参的任何操作都会影响到主调函数中的实参变量。

引用传递的方式是在函数定义时，在形参前面加上**引用运算符** “`&`”。

#### 嵌套调用

首先需要说明的是，在C++中，函数不允许嵌套定义，也就是说一个函数不能在另一个函数中进行定义。但在使用时，允许函数的嵌套调用，即在调用一个函数的过程中又调用另一个函数。且嵌套调用可是多层的。

#### 递归调用

递归调用指一个函数直接或间接的调用自身。直接递归指在一个函数中调用自身，间接递归调用指在一个函数中调用了其他函数，而其他函数又调用了本函数。

#### 默认形参

在C++中调用函数时，如果某以形参没有给出实参，则按其默认值赋值。当一个函数既有定义又有声明时，形参的默认值必须在声明中给定，而不能在定义中指定。只有当函数只有定义没有声明时，才可以在函数定义中指定形参的默认值。此外，默认值的定义必须遵守从右到左的顺序。

**注意**：形参的默认值可以为全局常量、全局变量、表达式、函数调用，但不能是局部变量，例如下面的程序是不合法的：

```
    int main()
    {
        int k;
        void func(int i = k);  // k为局部变量
    }
```

### 变量的作用域

一个程序将操作系统分配给其运行的内存块分为4个区域：

- 代码区：存放程序的代码，即程序中各个函数的代码块；
- 全局数据区：存放程序全局数据和静态数据；
- 堆区：存放程序的动态数据；
- 栈区：存放程序的局部数据，即各个函数中的数据。

#### 局部变量

在一个函数内部声明的变量，只在该函数范围内有效，因此被称为局部变量。

注意：在main()函数中声明的变量，也一样不能被其他函数使用，也是局部变量。

使用局部变量时需要注意以下几个事项：

- 形参变量也是内部变量，属于被调用函数；实参变量则是主调函数的内部变量。
- 允许在不同的函数中使用相同的变量名，但它们代表不同的对象，分配不同的内存单元，互不干扰。
- 在复合语句中也可以定义变量，其作用域只在复合语句范围内。

#### 全局变量

全局变量又称为外部变量，是在函数外部定义的变量。

注意：全局变量不属于任何一个函数，可被作用域内的所有函数直接引用，其作用域从外部变量的定义位置开始，到本文件结束为止。

虽然有时候使用全局变量可以很方便的完成任务，但全局变量使得函数之间的独立性降低了，这并不符合结构化程序设计的思想，因此，应尽量少用全局变量。

此外，对于全局变量还有以下几点说明:

- 在同一源文件中，允许外部变量和内部变量同名，在内部变量的作用域内，外部变量将被屏蔽不起作用。
- 全局变量的作用域是从定义点到本文件结束，如果定义点之前的函数需要引用这些外部变量时，需要在函数内对被引用的外部变量进行说明，格式为：
```
    extern 数据类型 外部变量[,外部变量2,...];
```
### 函数的作用域

每个函数都构成了一个函数作用域，它的概念与变量的存储位置和生命期有关。函数的参数和在函数中声明并定义的变量（即局部变量），其被分配在堆栈上，随着函数的执行而生成，随着函数的退出而消亡。

标号是唯一具有函数作用域的标识符，goto语句使用标号。标号声明使得该标识符在一个函数内的任何位置均可以被使用。

### 函数重载

函数重载是指同一个函数名可以对应着多个函数的实现。每一类实现对应着一个函数体，这些函数的名字相同，但是函数的参数的类型不同，这就是函数重载。

例如，给同一个名为sum()的函数定义两个不同的函数体，该函数的功能是实现两个数的相加。其中，一个实现求两个整数的和，另一个实现求两个浮点数的和，这两个功能均可以通过调用sum()函数实现。

#### 函数的重载

函数重载又称为函数的多态性，指同一个函数名对应着多个函数。所谓“不同”，可以是形参个数不同，也可以是形参类型不同，或者两者均不相同。例如，下面是合法的重载函数：

```
    int func1(int);
    int func1(int, int);
    double func1(int, long);
```

可见，重载函数的返回类型，可以相同，也可以不同，但如果仅仅是返回类型不同，形参表完全相同，则是不合法的。这种情况，编译器会视为对同一个函数原型的多次声明。

在调用一个重载函数的时候，编译器必须判断该函数名对应的是哪个函数。一般是根据实参的个数和类型对所有的同名函数的形参一一比较，从而调用一个最匹配的函数。

---

## 编译预处理

预处理是指编译器在进行第一次扫描之前所做的工作，C++编译器对一个源文件进行编译时，它将自动调用预处理程序对源程序中的预处理部分做处理，处理完成后才进行编译。这样做的好处是，处理后的代码，将变得很精短。

C++提供的预处理功能，包括宏定义、包含文件处理、条件编译等。

### 预处理命令

C++提供了丰富的预处理命令，主要包括：#define、/#error、#if、#else、#elif、#endif、#ifdef、#ifndef、#undef、#line和#pragma。

上面的预处理命令可以划分为文件包含、条件编译、布局控制和宏替换4个大类：

- 文件包含：#include是一种最为常见的预处理；

- 条件编译：（#if、#else、#elif、#endif、#ifdef、#ifndef、#undef等）也是比较常见的预处理，主要用于有选择的编译，注释掉一些指定的代码，以达到版本控制、防止对文件重复包含的功能。

- 布局控制：（#progma）也是应用预处理的一个重要方面，主要功能是为编译程序提供非常规的控制流信息。

- 宏替换：（#define）也是极为常见的用法，其可以定义符号常量、函数功能、重新命名、字符串的拼接等各种功能。
 
### 宏

宏（macro）是程序设计语言中使用较为广泛的一个概念，在C++中，通过宏的使用，可以将一个表达式定义为宏，并在C++源程序中随意调用。

在C++语言中，允许用一个标识符来表示一个字符串，称为“宏”。被定义为宏的标识符称为宏名。在编译预处理时，对程序中所有出现的宏名，都用宏定义中的字符串去代替，这称为宏代换或宏展开。在定义宏时需要注意：

- 宏名一般用大写；

- 使用宏可提高程序的通用性和易读性，减少不一致性，减少输入错误、便于更改。例如：数组大小常用宏定义。

- 预处理是在编译之前的处理，而编译工作的任务之一就是语法检查，预处理不做语法检查。

在C++中，宏分为有参数和无参数两种。

#### 无参数的宏定义

所谓无参数的宏，即宏名后不带参数，定义的一般形式为：

```
    #define 标识符 字符串
```

其中：

- “#”表示这是一条预处理命令，#define为宏定义命令；

- “标识符”为所定义的宏名；

- “字符串”可以是常数、表达式、格式串等。

```
    #define M (b*b+4*a*c)  //定义一个宏表达式，注意表达式两侧的括号不可少，如果没有括号，则代换后也没有括号，将发生运算优先级错误
    #include <iostream>
    using namespace std;
    
    int main()
    {
        int a, b, c;
        cout<<"equation ax^2+bx+c, please enter param a,b,c :"<<endl;
        cin>>a>>b>>c;
        if (M<0)  //可用宏名代替表达式
        {
            cout<<"方程无实数解"<<endl;
        }
        else
            cout<<"方程存在实数解"<<endl;
    }   
```
使用宏定义时需要注意：

- 宏定义是用宏名来表示一个字符串，在宏展开时将其反替换回去，这个过程只是一个简单的替换，字符串中可以含有任何字符，可以是常数，也可以是表达式，预处理程序对它不作任何检查。

- 宏定义并非说明语句，在行末不必加分号，如加上分号，则连分号一起替换。

- 宏定义必须写在函数之外，其作用域从宏定义命令开始，到程序结束为止。

- 一般来说，宏定义用大写字母表示，以便与变量区别，但也允许用小写字母。

#### 取消宏

由于宏定义的作用域是整个源程序，而有些情况下不需要其覆盖整个程序，此时则需要终止其作用，C++中取消宏定义的命令为#undef。如果要求宏只在一个函数中起作用，就可以在函数之前定义宏，在函数结束后取消宏。

```
    #define PI 3.1415926  //定义宏
    #include <iostream>
    
    int main()
    {
        ;  //空语句
    }
    # undef PI  //取消宏
```    

#### 宏嵌套

宏定义允许嵌套，即在宏定义的字符串中允许使用已经定义过的宏，在宏展开时由预处理程序进行逐层替换。

```
    #define PI 3.1415926
    #define S PI*r*r
```

#### 带参数的宏定义

C++中还允许宏带有参数，与函数定义时一样，在宏定义中的参数称为形式参数，在宏调用中的参数称为实际参数。

与无参数的宏不同的是，带参数的宏在调用时，预处理程序不仅要展开宏，还要用实参去替代形参。

带参数的宏定义的一般形式如下：

```
    #define 宏名(形参表)  字符串
```

例如：

```
    #define  MAX(x,y)  x>y?x:y   //定义带参数的宏
    #include <iostream>
    using namespace std;
    
    int main()
    {
        int a,b,max;
        cout<<"input two number:"<<endl;
        cin>>a>>b;
        max=MAX(a,b);
        cout<<"the bigger one is:"<<max<<endl;
    }
```

对于带参数的宏，定义时需注意：

- 带参宏定义中，宏名和参数表之间不能有空格，如果有空格将被认为是无参宏定义，参数表将和后面的字符串一起被认为是无参宏的字符串而进行替换。

- 在带参宏定义中，形参不分配内存单元，因此不必做类型定义。但宏调用中的实参有具体的值，必须进行类型说明，这是与函数不同的。在函数中，形参和实参各有自己的作用域，调用时需要进行实参到形参的值传递。而在带参宏中，仅仅是符号代换，不存在值传递。

- 在宏定义中的形参是标识符或变量，而宏调用中的实参则不必一定是变量或常量，也可以是表达式。因此，在宏定义中，字符串中的形参一般要用括号括起来避免出错。

```
    #define SQ1(y)  (y)*(y)  //定义
    #define SQ2(y)  ((y)*(y)) //整体加上括号
    int main()
    {
        int a=3;
        res1 = 15/SQ1(a+2);  //调用，相当于15/(a+2)*(a+2)=25
        res2 = 15/SQ2(a+2);  //调用，相当于15/((a+2)*(a+2))=3/5
    }
```

可见，由于带参宏只是单纯的符号替换，因此使用时一定要注意，调用后是否符合需求。

### 文件包含

文件包含是指一个C++源程序中将另一个C++源程序包含进来，通过#include预处理指令实现。

#### include指令

C++中，include被称为文件包含命令，其意义是将尖括号或引号中指定的文件包含到本程序中，成为本程序的一部分。被包含的文件通常是由系统提供的，其扩展名为.h，也成为头文件或首部文件。

文件包含命令 `#include <文件名>`和`#include "文件名"`的区别是：

使用尖括号表示在包含文件的目录中查找，而不是在源文件目录中查找；使用双引号则表示首先在当前的源文件目录中查找，未找到才到包含目录中去查找。因此，如果要包含用户自己编写的源文件，则最好选择后者。

在程序设计中，文件包含是很有用的。有利于模块化编程，而且，有些公用的符号常量或宏定义等可单独组成一个文件，在其他文件开头用包含，命令包含该文件即可使用。

在使用文件包含命令时需注意：

- 一个include命令只能指定一个被包含文件，若有多个文件要包含，则需要用多个include命令。

- 文件包含允许嵌套，即在一个被包含的文件中又可以包含另一个文件。

- 编译时，只需编译main()函数所在的源文件即可，因为系统会根据#include指令将所包含的内容拷贝至当前文件的当前位置。
### 条件编译

条件编译可以按照不同的条件去编译不同的程序部分，因而产生不同的目标代码文件，这对于程序的移植和调试是很有用的。C++的条件编译有三种形式。

#### `#ifdef`形式

该形式的结构如下所示：

```
    #ifdef 标识符
        程序段1
    #else
        程序段2
    #endif
```

其功能是，如果标识符已被#define命令定义过，对程序段1进行编译，否则对程序段2进行编译。如果程序段2为空，则也可以没有#else，其形式可以改写为：

```
    #ifdef 标识符
        程序段
    #endif
```

#### `#ifndef`形式

和#ifdef形式相同，功能相反，如果标识符未被定义则编译第一段，否则编译第二段。

#### `#if`形式

结构如下：

```
    #if 常量表达式
        程序段1
    #else
        程序段2
    #endif
```

其功能为：如果表达式的值为真，则对程序段1进行编译，否则编译程序段2。

**注意**：虽然条件编译的功能用if语句都可以实现，但是对于较长的源程序，为了使得生成的目标代码较短，建议采用条件编译的方式实现。

### 其他预处理命令

- `#erro`命令：用于程序的调试，在程序中遇到#error指令便停止编译，结构如下：

```
    #error 出错信息  // 当编译器遇到该指令，显示错误信息并停止编译
```
        C++提供该指令的目的是保证程序按照用户所设想的那样进行编译。例如，当程序比较大时，往往有些宏是在外部指定的，或是在头文件中指定的。此时，如果用户不确定当前是否定义了某个宏时，就可以改成如下这样进行编译：

```
    #ifdef XXX
        # error "XXX has been defined."
    #else
        ...
    #endif
```
        这样，如果编译出现“xxx has been defined”的提示，则表明宏XXX已经被定义过了。

- `#line`命令：用于控制行号，其一般在发布错误和警告信息时使用。当用户在编译一段程序的时候，若有错误发生，编译器会在错误前面显示出错文件的名称及文件第几行发生了错误。#line即可实现这个功能，其格式为：
```
    #line number “filename”  //此处的number是将会赋值给下一行的新行数，后面的行数将从这个点开始逐个递增。“filename”是个可选参数，用来替换自此行之后出错时显示的文件名，直至有另一个#line指令替换它或到文件末尾。
        
```
---
## 数组

与普通的数据类型不同，数组类型是一种构造型（复合型）的数据类型。

一般情况下，一个数组的元素类型必须相同。

一个数组可以是一维的，也可以是多维的。

### 声明数组

简单来讲，数组是由一些具有相同数据类型的元素组成的集合，这些元素在内存中占用一组连续的内存单元，而数组的类型也就是这些元素的数据类型。在C++中，用一个统一的名称标识这一组数据，即数组名。

需要注意的是，数组元素的编号（索引）是从0开始的。

#### 声明一维数组

一维数组的声明一般形式为：

```
    <类型名> <数组名> [<下标表达式>]={<初值表>};
```

其中，各部分含义为：

- 类型名：表示数组类型，可以是整型、浮点型等基本类型，也可以是基本类型的派生类型名、类名、枚举类型名、结构、联合类型名。

- 数组名：是一个标识符，表示数组元素在内存中的起始位置，其命名规则同变量名。

- 下标表达式： 是一种表达式，很多情况下是一个正整数，表示数组的大小，即一维数组中元素的个数。下标表达式要用方括号括起来，方括号的个数表示数组的维数，一个方括号表示一维数组。方括号不可缺省，下标表达式可以缺省，但此时必须对数组赋初值，系统会根据初值的个数来确定数组的大小。

- 初值表：是可以缺省的，如果要在声明时赋初值，则初值需要用大括号“{}”括起来，并用逗号“，”分开每个初值。

注意：下标为表达式时，该表达式必须为一个常量。即在定义数组时，不能用变量来描述数组定义中的元素个数。

#### 声明多维数组

多维数组的声明一般形式为：

```
    <类型名> <数组名> [<下标表达式1>][<下标表达式2>]...[<下标表达式n>];
```
最常用的多维数组是2维数组，其语法格式可简化为：

```
    类型 数组名 [常量表达式1] [常量表达式2]；
```
其中，第一个表达式表示数组的行数，第二个表示数组的列数。

如：
```
    int a[2][3];  //表示一个2行3列的数组，且其各元素均为整型
```

二维数组在内存中的排列顺序是“先行后列”，即先存储第一行的元素，再存储第二行。

### 引用数组

- 引用一维数组的形式：`<数组名> [<下标>]`。

- 引用多维数组的形式：`<数组名>[<下标1>][<下标2>]...[<下标n>]`

**注意**：为了提高程序的执行速度，C++不对数组的越界引用做检查（也就是编译器不会报错），所以需要额外注意该问题，否则会产生意想不到的错误。

###数组的赋值

- 初始化数组: 

```
    char a[5]={'a','b','c','d','e'};  //指定范围，全部初始化
    char b[5]={'a','b'};  //部分初始化，其余的系统默认初始化为0（数值数组）或空字符`\0`（字符数组）
    char c[]={'f','g','h'};  //不指定数组范围，默认为初始值长度
```
**注意**：当数组长度与初始化元素个数不相等时，数组长度不能省去不写。

- 通过赋值表达式赋值

```
    int a[5];
    a[3] = 4;
    a[0] = 2;
```

- 通过输入语句赋值

- 通过循环语句赋值

```
    int a[10],i;
    for(i=0;i<10;i++)
        a[i]=i;
```

### 字符串

在C++中，字符串实际上是使用 null 字符 '\0' 终止的一维字符数组。字符串有两种表示方法：C风格字符串和C++引入来的string类类型。

#### C风格字符串

```
    char greet[6]={'H','e','l','l','o','\0'};  //也可以不写末尾的null字符，编译器会自动加上该字符
    // 依据数组初始化原则，也可以写作
    char greet[]="Hello";
```

C++中有大量的函数用来操作以null结尾的字符串：

- strcpy(s1,s2)：用于复制字符串s2到字符串s1。

- strcat(s1,s2)：连接s2到s1的末尾。

- strlen(s)：计算字符串的实际长度（不包括null字符）。

- strlwr(s)：将字符串中的大写字母转为小写。

- strupr(s)：将字符串中的小写字母转为大写。

- strcmp(s1,s2)：比较字符串，如果s1和s2相同，则返回0；如果`s1<s2，则返回值小于0；如果s1>s2`，则返回值大于0。

- strchr(s1,ch)：返回一个指针，指向字符串s1中字符ch第一次出现的位置。

- strstr(s1, s2)：返回一个指针，指向字符串s1中字符串s2第一次出现的位置。

**注意**：使用这些函数之前，需要包含`<cstring>`类。

####C++中的string类

C++标准库提供了string类类型，支持上述所有操作(如果要用上面的函数，也需要包含 cstring头文件)，另外还增加了很多其他的功能。

看一个例子：

```
#include <string>
using namespace std;

int main()
{
    string str1="hello";
    string str2="zhouxr";
    string str3；
    int len;
    str3=str1;  //复制str1到str3
    str3=str1+str2;  //连接str1和str2
    len=str3.size();  //str3的长度（不包括null字符）
    
    return 0；
}
```

### 数组与函数

数组有两个特殊的性质:

- 不能复制数组：(不能写作数组a=数组b)。

- 使用数组名时，数组会自动转化为指向其第一个元素的指针。

在实际应用中，数组经常作为函数的参数，将数组数据传递到另一个函数，一般来说，传递可以采用两种方法：

- 数组元素作为函数的参数：用法和普通变量相同，属于值传递。如下：

```
void func(int);

int main()
{
    int a[3]={1,2,3};
    func(a[0]);  //数组元素作为函数的参数
}
```

- 数组名作为函数的参数：此时传递的是数组的地址，这样形参数组和实参数组占用同一段内存单元，当形参值发生变化时，实参值也会发生变化。

此时需要注意：

- 实参数组和形参数组的类型要一致。

- 形参数组的长度不要超过实参数组的长度。实参数组必须定义为具有确定长度的数组，而形参数组可以不定义长度，只在数组名后加一个空的方括号，同时在被调用函数中另设一个参数来表示传递元素的个数。

- 可以在被调用函数中采用降维处理，即用单重循环来遍历二维数组。此时调用函数中的数组不要用数组名表示，而要用第一个元素的地址表示。

有三种定义形式：

```
    void func(int *);
    void func(int [ ]);  //调用时，数组会自动转化为指针，形参复制的是指针的值
    void func(int [10]);  //编译器会忽略第一维数组的长度，所以以上三种定义形式是等价的
```

调用时：
```
    int a[10]=[1,2,3,4,5,6,7,8,9,0];
    func(a);  //数组名作为参数传递
```
一般情况下，为了便于遍历，会选择加数组的长度作为第二个参数：
```
    void func(int [ ], int len);  //声明
    //调用
    int a[10]=[1,2,3,4,5,6,7,8,9,0];
    int len_a=10;
    func(a, len_a);  //数组名作为参数传递，数组长度为第二个参数
```
---
## 结构（struct）

结构是一种比数组更灵活的数据格式，它可以存储不同数据类型的数据，比如一个人的个人信息（姓名、身高、年龄等），在某些情况下应用很方便。（如果要描述一个班级学生的信息，则可以使用结构数组）。

创建结构包括两步：

- 定义结构描述（它描述并标记了能够存储在结构中的各种数据类型）

- 按照描述创建结构变量

例如：

```C++
enum Sex  //声明一个枚举类型
{
	female,male,other  //默认为0,1,2
}; 

struct student  //定义一个结构描述
{   
    char name[20];
    enum Sex sex;  //枚举变量
    int age;
    float height;
};
// 上面的声明均属于外部声明，后面的函数均可使用，如果写在main函数中，则属于局部声明，作用域不同
int main()
{
    //创建结构变量
    struct student bob= 
    {
    	"Bob",  //name value
    	male, //sex
    	12,  //age
    	160  //height
    };   
    //通过成员运算符.来访问各个成员
    cout<<bob.name<<"'s age is "<<bob.age<<endl;
} 
    
```

## 共用体（union）

共用体是一种数据格式，它能够存储不同的数据类型，但只能同时存储其中的一种类型。它的句法和结构（struct）类似，但含义不同。

```c++
    // 声明一个共用体
    union oneForAll
    {
        int int_val;
        long long_val;
        double double_val;
    }
    
    //创建一个共用体
    oneForAll a;
    a.int_val = 10;  //则此时存储10
    a.double_val = 10.123  //此时存储10.123,int value被丢弃
```

关于共用体，有几点说明：

- 有匿名共用体的概念，无需给出共用体的名字，其成员将成为相同地址处的变量，但同一时刻只能有一个成员活动（哪个活动由程序员决定）。

- 共用体常用于节省内存、操作系统数据结构或硬件数据结构。

---

## 枚举（enum）

C++提供了枚举类型，本质上是创建的符号常量，某些情况下可以用这种方式代替const。而且，它还允许定义新类型，但必须按严格的限制进行。其使用句法与struct相似，如下：

```c++
    // 声明一个枚举类型
    enum color
    {
        red,
        green,
        blue  //默认情况下，三个符号常量的值分别为0,1,2，可以通过显式指定整数值来修改默认值
    };
```
使用枚举变量需注意：

- 在不进行强制类型转换的情况下，只能为其赋值定义时的枚举量

- 枚举变量只有赋值运算符，没有算术运算符等一些其他的运算符

- 枚举变量的值只能为整数

- 可以创建多个值相同的枚举变量

- 可以通过强制类型转换，增加可赋给枚举变量的合法值（必须在取值范围内，取值范围的上下限由枚举量的最大值和最小值决定：上限为大于最大值的、最小的2的幂减1；
若最小值大于等于0，则下限为0，否则下限为小于最小值的、最小的2的幂加1）

---

## 指针

指针是C++中的一个重要的概念，使用指针可使得程序简洁、紧凑、高效。

### 指针概述

简单来讲，指针是一个地址，其指向某个数据的存储地址。指针变量是一种特殊的变量，它是将一个地址存放在一个变量中，操作时要先找出该变量中存储的地址，
再通过地址找到最终要访问的变量。

我们说指针变量p指向变量a，即是指p中存有变量a的地址。

此外，指针除了可以指向变量之外，还可以指向内存中其他的任何数据结构，如数组、结构体和联合体等，也可以指向函数。

需要注意，在程序中参与数据处理的量不是指针本身的量（地址量），而是指针所指向的内存区域中的数据。

#### 定义指针

前面提到了，指针是一个变量，所以在程序中必须先声明，后使用。在指针声明的同时也可以进行初始化。指针的定义指出了指针的存储类型和数据类型，语法格式如下：

```
    存储类型名 数据类型 *指针变量名
```

其中，各部分的作用如下：

- 存储类型名：C++中的存储类型一般有静态存储、栈和自动类型等三种，一般默认的为自动类型auto。

- 数据类型：可以是任一基本类型名、派生类型名或自定义类型名；也可以是由 `<类型名>*`表示的指针类型名，称其为多级指针。

**注意**：把指针指向的变量的数据类型称为指针的数据类型；而任何一个指针变量本身数据值的类型都是unsigned long int。

例如，下面定义了几种指针：

```
    int* p1;  //和int *p1等价，但不建议采用第二种写法，前者更容易理解
    char* p2;
    static int* p3;   //静态存储
    
    //定义时初始化,将a的内存地址作为初始值赋予int型指针p4
    int a, *p4=&a;  //也可以分开写，p4指向a
    
    //定义一个空指针
    int* px=0;
```

上述定义中，指针变量前的`*`符号表示指向运算。当指针变量的类型确定后只能指向这种既定的数据类型。

为了使用安全起见，定义指针时，最好进行初始化，哪怕是初始化为空指针（值为0的指针叫做空指针）。

也可以向一个指针赋初值为另一个指针变量，此时这两个指针指向同一个内存地址：

```
    int n;
    int* p1=&n;
    int* p2=p1;
    //等价于 int* p2=&n;
```
可以通过指针访问变量的值，也可以通过它来间接给变量赋值。

```
int a=0;
int* p=&a;  
*p=10;//相当于a=10
```
### 指针的运算

所谓指针运算，是指以指针变量所持有的地址值作为运算量进行的运算。因此，指针运算的实质是地址的运算。指针运算的种类是有限的，它只能进行取地址运算、取值运算、算术运算、关系运算和赋值运算。

#### 取地址与取值运算

- `&`运算符：取地址运算符，&a即为取a的地址

- `*`运算符：指针运算符，或指向运算符，`*p`表示p所指向的变量，即可以由此取出变量中的值。
假设有一个指针变量px，则下面三种格式所代表的含义为：

- px：指针变量，它的内容是某个变量的地址。
- *px：指针的目标变量，它的内容是数据。
- &px：指针变量占用的存储区域的地址。

#### 指针的算术运算

由于指针变量存储的是地址值，故指针的算术运算与指针指向的数据类型有密切关系，也就是C++语言的地址计算与地址中存放的数据长度有关。

设px和py是指向具有相同数据类型的一组若干数据的指针，n是整数，则指针的算术运算有如下几种：

```
     px+n,  px-n,   px++,   ++px
     px--, --px,    px-py
```
下面分别介绍这几种算术运算的实现：

1. 指针与整数的加减运算

    指针作为地址量加上或减去一个整数n，其意义是指针当前指向位置的前方或后方第n个数据的位置，这种运算的结果取决于其指向的数据类型的长度。

    对于某种数据类型的指针p而言：

    - p+n的实际操作为：(p)+n*sizeof(数据类型)
    - p-n的实际操作为：(p)-n*sizeof(数据类型)

    在C++中，指针加减运算一般用在对数组元素进行操作的场合。

2. 指针加1、减1运算

    和上面的运算一样，也是地址运算，指向下一个或上一个数据的位置，故也称为后置运算和前置运算。

3. 指针的相减运算

    如果两个指针所指的变量数据类型相同，则可以进行相减运算。px-py的运算结果是两个指针指向的地址位置之间的数据个数（差值）。他执行的运算不是单纯的两地址值相减，而是：

```
        (px-py)/sizeof(数据类型) 
```
    
    例如：

```
        int a[]={11,23,33,24,15};
        int* p1=&a[0];  //此时p1指向第一个元素的值
        int* p2=&a[1];  
        cout<<"p2-p1="<<p2-p1<<endl;  //输出1
        cout<<"*(p1++)="<<*(p1++)<<endl;  //输出23
```

#### 指针的关系运算

在两个指向相同类型变量的指针之间可以进行各种关系运算，两指针变量之间的关系运算表示的是他们指向的地址之间的关系。

两指针相等的概念是两指针指向同一位置。

指向不同数据类型的指针之间的关系运算是没有意义的。

可以根据指针和0的比较来判断其是否是空指针。

#### 指针的赋值运算

当向指针变量赋值时，所赋的值必须是地址常量或变量，不能是普通整数。指针赋值运算常见的有以下几种形式：

- 把一个变量的地址赋予一个指向相同数据类型的指针变量。

- 把一个指针变量的值赋予具有相同数据类型的指针变量。

- 把数组的地址赋予指向相同数据类型的指针。如下：

```
char a[10];
char* pr;
pr=a;  //数组名即是一个指向数组第一个元素的指针变量
```

#### void指针 

在C++语言中，可以声明指向void类型的指针，即不指定指针指向一个固定的数据类型，其定义格式为：

```
    void* p;
```
它表示指针变量p不指向一个确定的类型数据，它的作用仅仅是用来存放一个地址。void指针可以指向任何类型的C++数据，也就是说可以用任何类型的指针直接给void指针赋值。

```
    int a;
    int* p1=&a;
    void* p2;
    p2=p1;
```

但如果需要将void指针赋值给其他类型的指针，则需要强制类型转换：

```
    int* p3=(int*) p2;
```

#### const指针

如果指针定义前加上const关键字，就包含一些特殊的含义，而关键字const放在不同的位置表示的意义也不相同，主要如下：

- `const int* p`表示声明一个指向常量的指针。此时，在程序中不能通过指针来改变它所指向的值。但指针变量本身的值可以改变，也就是说这个指针变量还可以指向其他的常量数据的地址。

- `int const* p`表示声明一个常指针(指针常量)，此时指针变量本身的值不可变（也就是说存储的地址不能变），但其指向的变量的值可以改变。

- `const int const* p`表示声明一个指向常量的常指针，此时指针变量和其指向的数据的值都不能通过指针改变。

### 指针与数组

指针在数组中使用较为频繁，由于数组名代表是该数组的首地址，所以如果要定义一个指针指向数组，可以做如下声明：

```
    int a[10];
    int* p=a;  //相当于int* p=&a[0]
    p[0]  //相当于a[0]
    *p  //也相当于a[0]
    *(p+1) //等价于p[1]，a[1]
```

#### 访问数组元素的方法

1. 下标法：即指出数组名和下标值。

2. 地址法：以数组a[5]为例，a的值为数组的起始地址，即a指向a[0]，a+1指向a[1]，同样的，a+i就指向a[i]，即`*(a+i)`就是`a[i]`。

3. 指针法：还是上面的例子，如果定义指针变量p指向数组的首地址，则可以通过`*(p+i)` 来访问`a[i]`。

#### 多维数组元素的访问

假设有一个简单的二维数组a[3][5]（三行五列），在C++中，以a[0]、a[1]和a[2]分别表示第0行、第1行和第2行的起始地址（即a[0]的值等于&a[0][0]，a[2]的值等于&a[2][0]）。因此，在同一行中，a[0]+j就等于&a[0][j]。所以，对于二维数组中元素a[i][j]的访问有多种方法：

```
    *(*(a+i)+j)
    *(a[i]+j)
    *(a+i)[j]
    *(a+row*i+j)
```

#### 数组指针与指针数组

- 数组指针

```
    int (*p)[5];  //定义了一个指针变量p，指向一个包含5个元素的整型数组
    int a[5]={1,2,3,4};
    p=&a;
    cout<<"*p[0]="<<*p[0]<<endl;  //相当于*(&a[0])
```

- 指针数组：就是其元素为指针的数组，它是指针的集合，其每一个元素都是指针变量，并且它们具有相同的存储类型和指向相同的数据类型，语法格式为：

```
    数据类型*  指针数组名   [常量表达式]
    //如下
    int* p1[6];
    char* p2[2][3];
```

指针数组在使用前必须先赋值，也可以利用初始化赋值。一般来说，指针数组主要用于操作字符串，例如：

```
    static char* name[4]={"Tatsuya", "Minami", "Hiro",'Hikari'};
```
其中name是一维指针数组，每一个元素都是指向字符数据的指针数据类型。其中name[0]指向第一个字符串“Tatsuya”，name[1]指向“Minami”，...。用指针处理数组不仅可以节省内存，还可以提高运算效率。例如，想对4个姓名进行排序，交换地址比将字符串交换位置快得多。

```
    //对于上面的指针数组而言
    cout<<"name[0]="<<name[0]<<endl;  //将打印出Tatsuya(这是由于字符串本身是一个字符数组，name[0]即相当于该字符数组的首指针，也就是该数组名，可以直接用它输出字符数组)，可见访问数组元素直接用数组名即可。
```

### 指针与函数

利用指针做函数参数，可以方便的实现地址传递。函数可以返回指针，指针也可以指向函数。

#### 指针作为函数的参数

若函数的某个参数是指针，对这个函数的调用就是传址调用，也就是使实参指针和形参变量指向同一内存地址。因此，调用函数时，也会影响到实参的值。

虽然用指针做参数可以使得对形参的改变也对实参生效，但在函数中反复使用指针进行间接访问会降低程序的可读性，也容易产生错误。故在C++中扩充了引用的概念，即实现了指针的功能，又使得程序清晰易读。

**注意**：当以数据地址作为实参调用一个函数时，被调函数的形参也必须是可以接收地址的变量，且其数据类型必须与被传送的数据类型相同。由于数组名也是一个指针，故数组名做函数的参数也是传址调用。

#### 指针型函数

当一个函数的返回值是指针类型时，这个函数就是指针型函数。

通常非指针型函数调用结束后，只能返回一个数据。当需要从被调函数返回一批数据到主调函数时，就可以使用指针型函数来解决。指针型函数在调用后，返回一个指针。通过指针中存储的地址值，主调函数就能访问该地址中存放的数据，并通过指针算术运算访问这个地址前、后内存中的值。因此，通过对空间的有效组织（如字符串、数组等能前后顺序存放多个变量的数据类型），就可以返回大量数据。

定义指针型函数的一般形式如下：

```
    数据类型* 函数名 （参数表）  // 如 int* func(int a, int b)
```

其中，参数说明如下：

- 数据类型是函数返回指针所指向数据的类型；

- 参数表是函数的形参列表。











